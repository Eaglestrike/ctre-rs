// pub type Handle = *mut ::std::os::raw::c_void;
pub enum _Handle {}
pub type Handle = *const _Handle;

/// Convenience wrapper for making simple get calls.
#[macro_export]
macro_rules! cci_get_call {
    ($function:ident($($arg0:expr,)+ _: $type:ty $(, $arg1:expr)*$(,)*)) => {{
        let mut value: $type = Default::default();
        let error = unsafe { $function($($arg0,)* &mut value, $($arg1,)*) };
        if error == ErrorCode::OK { Ok(value) } else { Err(error) }
    }}
}

/* automatically generated by rust-bindgen */

#[allow(non_camel_case_types)]
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ErrorCode {
    OK = 0,
    CAN_MSG_STALE = 1,
    TxFailed = -1,
    /// !< Caller passed an invalid param
    InvalidParamValue = -2,
    /// !< CAN frame has not been received within specified period of time.
    RxTimeout = -3,
    /// !< Not used.
    TxTimeout = -4,
    /// !< Specified CAN Id is invalid.
    UnexpectedArbId = -5,
    /// !< Caller attempted to insert data into a buffer that is full.
    BufferFull = 6,
    CAN_OVERFLOW = -6,
    /// !< Sensor is not present
    SensorNotPresent = -7,
    FirmwareTooOld = -8,
    CouldNotChangePeriod = -9,
    /// !< User Specified General Error
    GeneralError = -100,
    SigNotUpdated = -200,
    NotAllPIDValuesUpdated = -201,
    GEN_PORT_ERROR = -300,
    PORT_MODULE_TYPE_MISMATCH = -301,
    GEN_MODULE_ERROR = -400,
    MODULE_NOT_INIT_SET_ERROR = -401,
    MODULE_NOT_INIT_GET_ERROR = -402,
    WheelRadiusTooSmall = -500,
    TicksPerRevZero = -501,
    DistanceBetweenWheelsTooSmall = -502,
    GainsAreNotSet = -503,
    IncompatibleMode = -600,
    /// !< Handle does not match stored map of handles
    InvalidHandle = -601,
    FeatureRequiresHigherFirm = -700,
    TalonFeatureRequiresHigherFirm = -701,
    /// !< Special Code for "isSensorPresent"
    PulseWidthSensorNotPresent = 10,
    GeneralWarning = 100,
    FeatureNotSupported = 101,
    NotImplemented = 102,
    FirmVersionCouldNotBeRetrieved = 103,
    FeaturesNotAvailableYet = 104,
    ControlModeNotValid = 105,
    ControlModeNotSupportedYet = 106,
    AuxiliaryPIDNotSupportedYet = 107,
    RemoteSensorsNotSupportedYet = 108,
    MotProfFirmThreshold = 109,
    MotProfFirmThreshold2 = 110,
}
#[allow(non_camel_case_types)]
#[repr(u32)]
/// Signal enumeration for generic signal access.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ParamEnum {
    OnBoot_BrakeMode = 31,
    QuadFilterEn = 91,
    QuadIdxPolarity = 108,
    ClearPositionOnIdx = 100,
    MotionProfileHasUnderrunErr = 119,
    MotionProfileTrajectoryPointDurationMs = 120,
    ClearPosOnLimitF = 144,
    ClearPosOnLimitR = 145,
    StatusFramePeriod = 300,
    OpenloopRamp = 301,
    ClosedloopRamp = 302,
    NeutralDeadband = 303,
    PeakPosOutput = 305,
    NominalPosOutput = 306,
    PeakNegOutput = 307,
    NominalNegOutput = 308,
    ProfileParamSlot_P = 310,
    ProfileParamSlot_I = 311,
    ProfileParamSlot_D = 312,
    ProfileParamSlot_F = 313,
    ProfileParamSlot_IZone = 314,
    ProfileParamSlot_AllowableErr = 315,
    ProfileParamSlot_MaxIAccum = 316,
    ProfileParamSlot_PeakOutput = 317,
    ClearPositionOnLimitF = 320,
    ClearPositionOnLimitR = 321,
    ClearPositionOnQuadIdx = 322,
    SampleVelocityPeriod = 325,
    SampleVelocityWindow = 326,
    FeedbackSensorType = 330,
    SelectedSensorPosition = 331,
    FeedbackNotContinuous = 332,
    RemoteSensorSource = 333,
    RemoteSensorDeviceID = 334,
    SensorTerm = 335,
    RemoteSensorClosedLoopDisableNeutralOnLOS = 336,
    PIDLoopPolarity = 337,
    PIDLoopPeriod = 338,
    SelectedSensorCoefficient = 339,
    ForwardSoftLimitThreshold = 340,
    ReverseSoftLimitThreshold = 341,
    ForwardSoftLimitEnable = 342,
    ReverseSoftLimitEnable = 343,
    NominalBatteryVoltage = 350,
    BatteryVoltageFilterSize = 351,
    ContinuousCurrentLimitAmps = 360,
    PeakCurrentLimitMs = 361,
    PeakCurrentLimitAmps = 362,
    ClosedLoopIAccum = 370,
    CustomParam = 380,
    StickyFaults = 390,
    AnalogPosition = 400,
    QuadraturePosition = 401,
    PulseWidthPosition = 402,
    MotMag_Accel = 410,
    MotMag_VelCruise = 411,
    LimitSwitchSource = 421,
    LimitSwitchNormClosedAndDis = 422,
    LimitSwitchDisableNeutralOnLOS = 423,
    LimitSwitchRemoteDevID = 424,
    SoftLimitDisableNeutralOnLOS = 425,
    PulseWidthPeriod_EdgesPerRot = 430,
    PulseWidthPeriod_FilterWindowSz = 431,
    YawOffset = 160,
    CompassOffset = 161,
    BetaGain = 162,
    EnableCompassFusion = 163,
    GyroNoMotionCal = 164,
    EnterCalibration = 165,
    FusedHeadingOffset = 166,
    StatusFrameRate = 169,
    AccumZ = 170,
    TempCompDisable = 171,
    MotionMeas_tap_threshX = 172,
    MotionMeas_tap_threshY = 173,
    MotionMeas_tap_threshZ = 174,
    MotionMeas_tap_count = 175,
    MotionMeas_tap_time = 176,
    MotionMeas_tap_time_multi = 177,
    MotionMeas_shake_reject_thresh = 178,
    MotionMeas_shake_reject_time = 179,
    MotionMeas_shake_reject_timeout = 180,
}
#[allow(non_camel_case_types)]
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ControlFrame {
    Control_3_General = 262272,
    Control_4_Advanced = 262336,
    Control_6_MotProfAddTrajPoint = 262464,
}
#[allow(non_camel_case_types)]
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ControlFrameEnhanced {
    Control_3_General = 262272,
    Control_4_Advanced = 262336,
    Control_5_FeedbackOutputOverride = 262400,
    Control_6_MotProfAddTrajPoint = 262464,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ControlMode {
    PercentOutput = 0,
    Position = 1,
    Velocity = 2,
    Current = 3,
    Follower = 5,
    MotionProfile = 6,
    MotionMagic = 7,
    MotionProfileArc = 10,
    Disabled = 15,
}
#[repr(u32)]
/// How to interpret a demand value.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DemandType {
    /// Ignore the demand value and apply neutral/no-change.
    Neutral = 0,
    /**
     * When closed-looping, set the target of the aux PID loop to the demand value.
     *
     * When following, follow the processed output of the combined
     * primary/aux PID output.  The demand value is ignored.
     */
    AuxPID = 1,
    /// Simply add to the output
    ArbitraryFeedForward = 2,
}
#[allow(non_upper_case_globals)]
pub const FeedbackDevice_CTRE_MagEncoder_Absolute: FeedbackDevice =
    FeedbackDevice::PulseWidthEncodedPosition;
#[allow(non_upper_case_globals)]
pub const FeedbackDevice_CTRE_MagEncoder_Relative: FeedbackDevice = FeedbackDevice::QuadEncoder;
#[repr(i32)]
/// Motor controller with gadgeteer connector.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FeedbackDevice {
    None = -1,
    QuadEncoder = 0,
    Analog = 2,
    Tachometer = 4,
    PulseWidthEncodedPosition = 8,
    SensorSum = 9,
    SensorDifference = 10,
    RemoteSensor0 = 11,
    RemoteSensor1 = 12,
    SoftwareEmulatedSensor = 15,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RemoteFeedbackDevice {
    None = -1,
    SensorSum = 9,
    SensorDifference = 10,
    RemoteSensor0 = 11,
    RemoteSensor1 = 12,
    SoftwareEmulatedSensor = 15,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FollowerType {
    PercentOutput = 0,
    AuxOutput1 = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum LimitSwitchSource {
    FeedbackConnector = 0,
    RemoteTalonSRX = 1,
    RemoteCANifier = 2,
    Deactivated = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RemoteLimitSwitchSource {
    RemoteTalonSRX = 1,
    RemoteCANifier = 2,
    Deactivated = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum LimitSwitchNormal {
    NormallyOpen = 0,
    NormallyClosed = 1,
    Disabled = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum NeutralMode {
    /// Use the NeutralMode that is set by the jumper wire on the CAN device
    EEPROMSetting = 0,
    /// Stop the motor's rotation by applying a force.
    Coast = 1,
    /// Stop the motor's rotation by applying a force.
    Brake = 2,
}
#[allow(non_camel_case_types)]
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RemoteSensorSource {
    Off = 0,
    TalonSRX_SelectedSensor = 1,
    Pigeon_Yaw = 2,
    Pigeon_Pitch = 3,
    Pigeon_Roll = 4,
    CANifier_Quadrature = 5,
    CANifier_PWMInput0 = 6,
    CANifier_PWMInput1 = 7,
    CANifier_PWMInput2 = 8,
    CANifier_PWMInput3 = 9,
    GadgeteerPigeon_Yaw = 10,
    GadgeteerPigeon_Pitch = 11,
    GadgeteerPigeon_Roll = 12,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SensorTerm {
    Sum0 = 0,
    Sum1 = 1,
    Diff0 = 2,
    Diff1 = 3,
}
#[allow(non_camel_case_types)]
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum StatusFrameEnhanced {
    Status_1_General = 5120,
    Status_2_Feedback0 = 5184,
    Status_4_AinTempVbat = 5312,
    Status_6_Misc = 5440,
    Status_7_CommStatus = 5504,
    Status_9_MotProfBuffer = 5632,
    Status_10_Targets = 5696,
    Status_12_Feedback1 = 5824,
    Status_13_Base_PIDF0 = 5888,
    Status_14_Turn_PIDF1 = 5952,
    Status_15_FirmareApiStatus = 6016,
    Status_3_Quadrature = 5248,
    Status_8_PulseWidth = 5568,
    Status_11_UartGadgeteer = 5760,
}
#[allow(non_camel_case_types)]
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum StatusFrame {
    Status_1_General = 5120,
    Status_2_Feedback0 = 5184,
    Status_4_AinTempVbat = 5312,
    Status_6_Misc = 5440,
    Status_7_CommStatus = 5504,
    Status_9_MotProfBuffer = 5632,
    Status_10_Targets = 5696,
    Status_12_Feedback1 = 5824,
    Status_13_Base_PIDF0 = 5888,
    Status_14_Turn_PIDF1 = 5952,
    Status_15_FirmareApiStatus = 6016,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SetValueMotionProfile {
    Disable = 0,
    Enable = 1,
    Hold = 2,
}
#[repr(u32)]
/// Duration to apply to a particular trajectory pt.
/// This time unit is ADDED to the existing base time set by
/// ConfigMotionProfileTrajectoryPeriod().
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum TrajectoryDuration {
    T0ms = 0,
    T5ms = 5,
    T10ms = 10,
    T20ms = 20,
    T30ms = 30,
    T40ms = 40,
    T50ms = 50,
    T100ms = 100,
}
/// Motion Profile Trajectory Point
/// This is simply a data transfer object.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TrajectoryPoint {
    /// !< The position to servo to.
    pub position: f64,
    /// !< The velocity to feed-forward.
    pub velocity: f64,
    /// !< The position for auxiliary PID to target.
    pub auxiliary_pos: f64,
    /// Which slot to get PIDF gains.
    /// PID is used for position servo.
    /// F is used as the Kv constant for velocity feed-forward.
    /// Typically this is hard-coded
    /// to a particular slot, but you are free to gain schedule if need be.
    /// gain schedule if need be.
    /// Choose from [0,3].
    pub profile_slot_select_0: u32,
    /// Which slot to get PIDF gains for auxiliary PID.
    /// This only has impact during MotionProfileArc Control mode.
    /// Choose from [0,1].
    pub profile_slot_select_1: u32,
    /// Set to true to signal Talon that this is the final point, so do not
    /// attempt to pop another trajectory point from out of the Talon buffer.
    /// Instead continue processing this way point.  Typically the velocity
    /// member variable should be zero so that the motor doesn't spin indefinitely.
    pub is_last_point: bool,
    /// Set to true to signal Talon to zero the selected sensor.
    /// When generating MPs, one simple method is to make the first target position zero,
    /// and the final target position the target distance from the current position.
    /// Then when you fire the MP, the current position gets set to zero.
    /// If this is the intent, you can set zeroPos on the first trajectory point.
    ///
    /// Otherwise you can leave this false for all points, and offset the positions
    /// of all trajectory points so they are correct.
    pub zero_pos: bool,
    /// Duration to apply this trajectory pt.
    /// This time unit is ADDED to the existing base time set by
    /// ConfigMotionProfileTrajectoryPeriod().
    pub time_dur: TrajectoryDuration,
}
#[test]
fn bindgen_test_layout_TrajectoryPoint() {
    assert_eq!(
        ::std::mem::size_of::<TrajectoryPoint>(),
        48usize,
        concat!("Size of: ", stringify!(TrajectoryPoint))
    );
    assert_eq!(
        ::std::mem::align_of::<TrajectoryPoint>(),
        8usize,
        concat!("Alignment of ", stringify!(TrajectoryPoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TrajectoryPoint>())).position as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TrajectoryPoint),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TrajectoryPoint>())).velocity as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TrajectoryPoint),
            "::",
            stringify!(velocity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TrajectoryPoint>())).headingDeg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TrajectoryPoint),
            "::",
            stringify!(headingDeg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TrajectoryPoint>())).auxiliaryPos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TrajectoryPoint),
            "::",
            stringify!(auxiliaryPos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TrajectoryPoint>())).profileSlotSelect0 as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TrajectoryPoint),
            "::",
            stringify!(profileSlotSelect0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TrajectoryPoint>())).profileSlotSelect1 as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(TrajectoryPoint),
            "::",
            stringify!(profileSlotSelect1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TrajectoryPoint>())).isLastPoint as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TrajectoryPoint),
            "::",
            stringify!(isLastPoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TrajectoryPoint>())).zeroPos as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(TrajectoryPoint),
            "::",
            stringify!(zeroPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TrajectoryPoint>())).timeDur as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(TrajectoryPoint),
            "::",
            stringify!(timeDur)
        )
    );
}
/// Motion Profile Status
/// This is simply a data transer object.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MotionProfileStatus {
    /// The available empty slots in the trajectory buffer.
    ///
    /// The robot API holds a "top buffer" of trajectory points, so your applicaion
    /// can dump several points at once.  The API will then stream them into the Talon's
    /// low-level buffer, allowing the Talon to act on them.
    pub top_buffer_rem: ::std::os::raw::c_int,
    /// The number of points in the top trajectory buffer.
    pub top_buffer_cnt: ::std::os::raw::c_int,
    /// The number of points in the low level Talon buffer.
    pub btm_buffer_cnt: ::std::os::raw::c_int,
    /// Set if isUnderrun ever gets set.
    /// Only is cleared by clearMotionProfileHasUnderrun() to ensure
    /// robot logic can react or instrument it.
    /// @see clearMotionProfileHasUnderrun()
    pub has_underrun: bool,
    /// This is set if Talon needs to shift a point from its buffer into
    /// the active trajectory point however the buffer is empty. This gets cleared
    /// automatically when is resolved.
    pub is_underrun: bool,
    /// True if the active trajectory point has not empty, false otherwise.
    /// The members in activePoint are only valid if this signal is set.
    pub active_point_valid: bool,
    pub is_last: bool,
    /// Selected slot for PID Loop 0
    pub profile_slot_select_0: ::std::os::raw::c_int,
    /// Selected slot for PID Loop 0
    pub profile_slot_select_1: ::std::os::raw::c_int,
    /// The current output mode of the motion profile executer (disabled, enabled, or hold).
    /// When changing the set() value in MP mode, it's important to check this signal to
    /// confirm the change takes effect before interacting with the top buffer.
    pub output_enable: SetValueMotionProfile,
    /// The applied duration of the active trajectory point
    pub time_dur_ms: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_MotionProfileStatus() {
    assert_eq!(
        ::std::mem::size_of::<MotionProfileStatus>(),
        32usize,
        concat!("Size of: ", stringify!(MotionProfileStatus))
    );
    assert_eq!(
        ::std::mem::align_of::<MotionProfileStatus>(),
        4usize,
        concat!("Alignment of ", stringify!(MotionProfileStatus))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MotionProfileStatus>())).top_buffer_rem as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MotionProfileStatus),
            "::",
            stringify!(top_buffer_rem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MotionProfileStatus>())).top_buffer_cnt as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MotionProfileStatus),
            "::",
            stringify!(top_buffer_cnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MotionProfileStatus>())).btm_buffer_cnt as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MotionProfileStatus),
            "::",
            stringify!(btm_buffer_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MotionProfileStatus>())).has_underrun as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MotionProfileStatus),
            "::",
            stringify!(has_underrun)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MotionProfileStatus>())).is_underrun as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(MotionProfileStatus),
            "::",
            stringify!(is_underrun)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MotionProfileStatus>())).active_point_valid as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(MotionProfileStatus),
            "::",
            stringify!(active_point_valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MotionProfileStatus>())).is_last as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(MotionProfileStatus),
            "::",
            stringify!(isLast)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MotionProfileStatus>())).profileSlotSelect0 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MotionProfileStatus),
            "::",
            stringify!(profile_slot_select_0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MotionProfileStatus>())).profile_slot_select_1 as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MotionProfileStatus),
            "::",
            stringify!(profile_slot_select_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MotionProfileStatus>())).output_enable as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MotionProfileStatus),
            "::",
            stringify!(output_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MotionProfileStatus>())).time_dur_ms as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MotionProfileStatus),
            "::",
            stringify!(time_dur_ms)
        )
    );
}
extern "C" {
    pub fn c_MotController_Create1(baseArbId: ::std::os::raw::c_int) -> Handle;
}
extern "C" {
    pub fn c_MotController_GetDeviceNumber(
        handle: Handle,
        deviceNumber: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetDescription(
        handle: Handle,
        toFill: *mut ::std::os::raw::c_char,
        toFillByteSz: ::std::os::raw::c_int,
        numBytesFilled: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_SetDemand(
        handle: Handle,
        mode: ::std::os::raw::c_int,
        demand0: ::std::os::raw::c_int,
        demand1: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_Set_4(
        handle: Handle,
        mode: ::std::os::raw::c_int,
        demand0: f64,
        demand1: f64,
        demand1Type: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_SetNeutralMode(handle: Handle, neutralMode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn c_MotController_SetSensorPhase(handle: Handle, PhaseSensor: bool);
}
extern "C" {
    pub fn c_MotController_SetInverted(handle: Handle, invert: bool);
}
extern "C" {
    pub fn c_MotController_ConfigOpenLoopRamp(
        handle: Handle,
        secondsFromNeutralToFull: f64,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigClosedLoopRamp(
        handle: Handle,
        secondsFromNeutralToFull: f64,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigPeakOutputForward(
        handle: Handle,
        percentOut: f64,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigPeakOutputReverse(
        handle: Handle,
        percentOut: f64,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigNominalOutputForward(
        handle: Handle,
        percentOut: f64,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigNominalOutputReverse(
        handle: Handle,
        percentOut: f64,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigNeutralDeadband(
        handle: Handle,
        percentDeadband: f64,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigVoltageCompSaturation(
        handle: Handle,
        voltage: f64,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigVoltageMeasurementFilter(
        handle: Handle,
        filterWindowSamples: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_EnableVoltageCompensation(handle: Handle, enable: bool);
}
extern "C" {
    pub fn c_MotController_GetBusVoltage(handle: Handle, voltage: *mut f64) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetMotorOutputPercent(
        handle: Handle,
        percentOutput: *mut f64,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetOutputCurrent(handle: Handle, current: *mut f64) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetTemperature(handle: Handle, temperature: *mut f64) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigSelectedFeedbackSensor(
        handle: Handle,
        feedbackDevice: ::std::os::raw::c_int,
        pidIdx: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigSelectedFeedbackCoefficient(
        handle: Handle,
        coefficient: f64,
        pidIdx: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigRemoteFeedbackFilter(
        handle: Handle,
        deviceID: ::std::os::raw::c_int,
        remoteSensorSource: ::std::os::raw::c_int,
        remoteOrdinal: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigSensorTerm(
        handle: Handle,
        sensorTerm: ::std::os::raw::c_int,
        feedbackDevice: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetSelectedSensorPosition(
        handle: Handle,
        param: *mut ::std::os::raw::c_int,
        pidIdx: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetSelectedSensorVelocity(
        handle: Handle,
        param: *mut ::std::os::raw::c_int,
        pidIdx: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_SetSelectedSensorPosition(
        handle: Handle,
        sensorPos: ::std::os::raw::c_int,
        pidIdx: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_SetControlFramePeriod(
        handle: Handle,
        frame: ::std::os::raw::c_int,
        periodMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_SetStatusFramePeriod(
        handle: Handle,
        frame: ::std::os::raw::c_int,
        periodMs: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetStatusFramePeriod(
        handle: Handle,
        frame: ::std::os::raw::c_int,
        periodMs: *mut ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigVelocityMeasurementPeriod(
        handle: Handle,
        period: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigVelocityMeasurementWindow(
        handle: Handle,
        windowSize: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigForwardLimitSwitchSource(
        handle: Handle,
        type_: ::std::os::raw::c_int,
        normalOpenOrClose: ::std::os::raw::c_int,
        deviceID: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigReverseLimitSwitchSource(
        handle: Handle,
        type_: ::std::os::raw::c_int,
        normalOpenOrClose: ::std::os::raw::c_int,
        deviceID: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_OverrideLimitSwitchesEnable(handle: Handle, enable: bool);
}
extern "C" {
    pub fn c_MotController_ConfigForwardSoftLimitThreshold(
        handle: Handle,
        forwardSensorLimit: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigReverseSoftLimitThreshold(
        handle: Handle,
        reverseSensorLimit: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigForwardSoftLimitEnable(
        handle: Handle,
        enable: bool,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigReverseSoftLimitEnable(
        handle: Handle,
        enable: bool,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_OverrideSoftLimitsEnable(handle: Handle, enable: bool);
}
extern "C" {
    pub fn c_MotController_Config_kP(
        handle: Handle,
        slotIdx: ::std::os::raw::c_int,
        value: f64,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_Config_kI(
        handle: Handle,
        slotIdx: ::std::os::raw::c_int,
        value: f64,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_Config_kD(
        handle: Handle,
        slotIdx: ::std::os::raw::c_int,
        value: f64,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_Config_kF(
        handle: Handle,
        slotIdx: ::std::os::raw::c_int,
        value: f64,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_Config_IntegralZone(
        handle: Handle,
        slotIdx: ::std::os::raw::c_int,
        izone: f64,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigAllowableClosedloopError(
        handle: Handle,
        slotIdx: ::std::os::raw::c_int,
        allowableClosedLoopError: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigMaxIntegralAccumulator(
        handle: Handle,
        slotIdx: ::std::os::raw::c_int,
        iaccum: f64,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigClosedLoopPeakOutput(
        handle: Handle,
        slotIdx: ::std::os::raw::c_int,
        percentOut: f64,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigClosedLoopPeriod(
        handle: Handle,
        slotIdx: ::std::os::raw::c_int,
        loopTimeMs: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_SetIntegralAccumulator(
        handle: Handle,
        iaccum: f64,
        pidIdx: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetClosedLoopError(
        handle: Handle,
        closedLoopError: *mut ::std::os::raw::c_int,
        pidIdx: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetIntegralAccumulator(
        handle: Handle,
        iaccum: *mut f64,
        pidIdx: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetErrorDerivative(
        handle: Handle,
        derror: *mut f64,
        pidIdx: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_SelectProfileSlot(
        handle: Handle,
        slotIdx: ::std::os::raw::c_int,
        pidIdx: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetActiveTrajectoryPosition(
        handle: Handle,
        param: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetActiveTrajectoryVelocity(
        handle: Handle,
        param: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetActiveTrajectoryHeading(handle: Handle, param: *mut f64)
        -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetActiveTrajectoryAll(
        handle: Handle,
        vel: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
        heading: *mut f64,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigMotionCruiseVelocity(
        handle: Handle,
        sensorUnitsPer100ms: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigMotionAcceleration(
        handle: Handle,
        sensorUnitsPer100msPerSec: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ClearMotionProfileTrajectories(handle: Handle) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetMotionProfileTopLevelBufferCount(
        handle: Handle,
        value: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_PushMotionProfileTrajectory(
        handle: Handle,
        position: f64,
        velocity: f64,
        headingDeg: f64,
        profileSlotSelect: ::std::os::raw::c_int,
        isLastPoint: bool,
        zeroPos: bool,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_PushMotionProfileTrajectory_2(
        handle: Handle,
        position: f64,
        velocity: f64,
        headingDeg: f64,
        profileSlotSelect0: ::std::os::raw::c_int,
        profileSlotSelect1: ::std::os::raw::c_int,
        isLastPoint: bool,
        zeroPos: bool,
        durationMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_IsMotionProfileTopLevelBufferFull(
        handle: Handle,
        value: *mut bool,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ProcessMotionProfileBuffer(handle: Handle) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetMotionProfileStatus(
        handle: Handle,
        topBufferRem: *mut ::std::os::raw::c_int,
        topBufferCnt: *mut ::std::os::raw::c_int,
        btmBufferCnt: *mut ::std::os::raw::c_int,
        hasUnderrun: *mut bool,
        isUnderrun: *mut bool,
        activePointValid: *mut bool,
        isLast: *mut bool,
        profileSlotSelect: *mut ::std::os::raw::c_int,
        outputEnable: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetMotionProfileStatus_2(
        handle: Handle,
        topBufferRem: *mut ::std::os::raw::c_int,
        topBufferCnt: *mut ::std::os::raw::c_int,
        btmBufferCnt: *mut ::std::os::raw::c_int,
        hasUnderrun: *mut bool,
        isUnderrun: *mut bool,
        activePointValid: *mut bool,
        isLast: *mut bool,
        profileSlotSelect: *mut ::std::os::raw::c_int,
        outputEnable: *mut SetValueMotionProfile, // XXX: changed from c_int
        timeDurMs: *mut ::std::os::raw::c_int,
        profileSlotSelect1: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ClearMotionProfileHasUnderrun(
        handle: Handle,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ChangeMotionControlFramePeriod(
        handle: Handle,
        periodMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigMotionProfileTrajectoryPeriod(
        handle: Handle,
        durationMs: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetLastError(handle: Handle) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetFirmwareVersion(
        handle: Handle,
        arg1: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_HasResetOccurred(handle: Handle, arg1: *mut bool) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigSetCustomParam(
        handle: Handle,
        newValue: ::std::os::raw::c_int,
        paramIndex: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigGetCustomParam(
        handle: Handle,
        readValue: *mut ::std::os::raw::c_int,
        paramIndex: ::std::os::raw::c_int,
        timoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigSetParameter(
        handle: Handle,
        param: ::std::os::raw::c_int,
        value: f64,
        subValue: ::std::os::raw::c_int,
        ordinal: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigGetParameter(
        handle: Handle,
        param: ::std::os::raw::c_int,
        value: *mut f64,
        ordinal: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigPeakCurrentLimit(
        handle: Handle,
        amps: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigPeakCurrentDuration(
        handle: Handle,
        milliseconds: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ConfigContinuousCurrentLimit(
        handle: Handle,
        amps: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_EnableCurrentLimit(handle: Handle, enable: bool) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_SetLastError(handle: Handle, error: ::std::os::raw::c_int) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetAnalogIn(
        handle: Handle,
        param: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_SetAnalogPosition(
        handle: Handle,
        newPosition: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetAnalogInRaw(
        handle: Handle,
        param: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetAnalogInVel(
        handle: Handle,
        param: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetQuadraturePosition(
        handle: Handle,
        param: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_SetQuadraturePosition(
        handle: Handle,
        newPosition: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetQuadratureVelocity(
        handle: Handle,
        param: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetPulseWidthPosition(
        handle: Handle,
        param: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_SetPulseWidthPosition(
        handle: Handle,
        newPosition: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetPulseWidthVelocity(
        handle: Handle,
        param: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetPulseWidthRiseToFallUs(
        handle: Handle,
        param: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetPulseWidthRiseToRiseUs(
        handle: Handle,
        param: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetPinStateQuadA(
        handle: Handle,
        param: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetPinStateQuadB(
        handle: Handle,
        param: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetPinStateQuadIdx(
        handle: Handle,
        param: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_IsFwdLimitSwitchClosed(
        handle: Handle,
        param: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_IsRevLimitSwitchClosed(
        handle: Handle,
        param: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetFaults(
        handle: Handle,
        param: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetStickyFaults(
        handle: Handle,
        param: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_ClearStickyFaults(
        handle: Handle,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_SelectDemandType(handle: Handle, enable: bool) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_SetMPEOutput(
        handle: Handle,
        MpeOutput: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_EnableHeadingHold(handle: Handle, enable: bool) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetAnalogInAll(
        handle: Handle,
        withOv: *mut ::std::os::raw::c_int,
        raw: *mut ::std::os::raw::c_int,
        vel: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetQuadratureSensor(
        handle: Handle,
        pos: *mut ::std::os::raw::c_int,
        vel: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetPulseWidthAll(
        handle: Handle,
        pos: *mut ::std::os::raw::c_int,
        vel: *mut ::std::os::raw::c_int,
        riseToRiseUs: *mut ::std::os::raw::c_int,
        riseToFallUs: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetQuadPinStates(
        handle: Handle,
        quadA: *mut ::std::os::raw::c_int,
        quadB: *mut ::std::os::raw::c_int,
        quadIdx: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetLimitSwitchState(
        handle: Handle,
        isFwdClosed: *mut ::std::os::raw::c_int,
        isRevClosed: *mut ::std::os::raw::c_int,
    ) -> ErrorCode;
}
extern "C" {
    pub fn c_MotController_GetClosedLoopTarget(
        handle: Handle,
        value: *mut ::std::os::raw::c_int,
        pidIdx: ::std::os::raw::c_int,
    ) -> ErrorCode;
}
